#!/usr/bin/env python
from math import acos, asin, atan2, cos, sin, degrees, fmod, pi, sqrt
import numpy as np

import rospy
import tf
from geometry_msgs.msg import Quaternion, TwistStamped
from nav_msgs.msg import Odometry

class Quat:
	def __init__(self,w,x,y,z):
		self.w = w
		self.x = x
		self.y = y
		self.z = z

	def mul(self, other):
		result = Quat(1,0,0,0)
		result.w = self.w*other.w - self.x*other.x - self.y*other.y - self.z*other.z
		result.x = self.x*other.w + self.w*other.x + self.y*other.z - self.z*other.y
		result.y = self.w*other.y - self.x*other.z + self.y*other.w + self.z*other.x
		result.z = self.w*other.z + self.x*other.y - self.y*other.x + self.z*other.w
		return result

	def diff(self, other):
		self.norm()
		other.norm()
		diff_quat = self.mul(other.inverse())
		return diff_quat.norm()

	def get(self):
		return self.w, self.x, self.y, self.z

	def getList(self):
		return [self.w, self.x, self.y, self.z]

	def inverse(self):
		result = Quat(1,0,0,0)
		norm_squared = self.w*self.w + self.x*self.x + self.y*self.y + self.z*self.z
		if(norm_squared == 0): norm_squared = 0.0000001
		result.w = self.w/norm_squared
		result.x = - self.x/norm_squared
		result.y = - self.y/norm_squared
		result.z = - self.z/norm_squared
		return result

	def conjugate(self):
		result = Quat(1,0,0,0)
		result.w = self.w
		result.x = - self.x
		result.y = - self.y
		result.z = - self.z
		return result

	def dot(self, other):
		result = self.w*other.w + self.x*other.x + self.y*other.y + self.z*other.z
		return result

	def norm(self):
		norm = sqrt(self.w*self.w + self.x*self.x + self.y*self.y + self.z*self.z)
		if(norm == 0): norm_squared = 0.0000001
		self.w /= norm
		self.x /= norm
		self.y /= norm
		self.z /= norm

	def getRotationMatrix(self):
		#Get euler angles.
		roll = self.euler[0]
		pitch = self.euler[1]
		yaw = self.euler[2]
		#Rotation matrix.
		rot_matrix = np.matrix([[cos(yaw)*cos(pitch),cos(yaw)*sin(pitch)*sin(roll)-sin(yaw)*cos(roll),cos(yaw)*sin(pitch)*cos(roll)+sin(yaw)*sin(roll)], 
			[sin(yaw)*cos(pitch),sin(yaw)*sin(pitch)*sin(roll)+cos(yaw)*cos(roll),sin(yaw)*sin(pitch)*cos(roll)-cos(yaw)*sin(roll)]
			[-sin(pitch),cos(pitch)*sin(roll),cos(pitch)*cos(roll)]])
		return rot_matrix

	def to_euler(self):
		return tf.transformations.euler_from_quaternion([self.w, self.x, self.y, self.z])

	def sendTransform(self, x,y,z, name, broadcaster):
		broadcaster.sendTransform((x,y,z), (self.x, self.y, self.z, self.w), rospy.Time.now(), name, "world")

	@property
	def w(self): return self.w
	@property
	def x(self): return self.x
	@property
	def y(self): return self.y
	@property
	def z(self): return self.z

	@w.setter
	def w(self,w): self.w = w
	@x.setter
	def x(self,x): self.x = x
	@y.setter
	def y(self,y): self.y = y
	@z.setter
	def z(self,z): self.z = z


class Comparor():
	def __init__(self):
		#Init ROS.
		rospy.init_node('rovio_car_model_orientation')
		rospy.Subscriber('car_model_velocity', TwistStamped, self.modelCallback, queue_size=10)
		rospy.Subscriber('rovio/odometry', Odometry, self.rovioCallback, queue_size=10)
		#Init quaternion.
		self.quat_rovio = Quaternion(0,0,0,1)
		self.quat_rovio_init = Quaternion(0,0,0,1)
		self.quat_rovio_init_soll = Quaternion(0,0,0,1)
		#Init velocities.
		self.vel_model = np.array([0,0,0])
		self.vel_rovio = np.array([0,0,0])

	def compare(self):
		#Get diff quaternion and rotation matrix.
		quat = Quaternion(0,0,0,1)
		quat2 = Quaternion(1,0,0,0)
		print(quat.getList())
		# diffQuaternion = self.quat_rovio_init.diff(quat_rovio_init_soll)
		# rot_matrix = diffQuaternion.getRotationMatrix()
		# #Rotate vel_model.
		# vel_model_rotated = rot_matrix.dot(self.vel_model)
		# print(vel_model_rotated)
		# #Get difference.
		# print(vel_model_rotated - self.vel_rovio)

	def modelCallback(self, msg):
		self.vel_model = np.array([msg.twist.linear.x,msg.twist.linear.y,msg.twist.linear.z])
		self.compare()

	def rovioCallback(self, msg):
		#Get quaternion.
		quat_rovio.x(pose.pose.orientation.x)
		quat_rovio.y(pose.pose.orientation.y)
		quat_rovio.z(pose.pose.orientation.z)
		quat_rovio.w(pose.pose.orientation.w)
		if(quat_rovio_init == Quaternion(0,0,0,1)): 
			quat_rovio_init = quat_rovio
			print(quat_rovio_init.getList())
		#Get velocity.
		self.vel_rovio = np.array([msg.twist.twist.linear.x,msg.twist.twist.linear.y,msg.twist.twist.linear.z])
		self.compare()

if __name__ == '__main__':
	comparor = Comparor()
	rospy.spin()

